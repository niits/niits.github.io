<!doctype html><html lang=vi-vn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>TrungTD/posts/state-of-serverless/</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=https://trungtd.me/hugo-theme-console/css/terminal-0.7.2.min.css><link rel=stylesheet href=https://trungtd.me/hugo-theme-console/css/animate-4.1.1.min.css><link rel=stylesheet href=https://trungtd.me/hugo-theme-console/css/console.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><meta property="og:title" content="Hiện trạng của Serverless"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://trungtd.me/posts/state-of-serverless/"><meta property="article:published_time" content="2022-03-25T23:23:47+07:00"><meta name=twitter:title content="Hiện trạng của Serverless"><meta name=twitter:description content="Bây giờ bạn đã có định nghĩa ban đầu về serverless và hai quan điểm chính về cách nó nên được xây dựng và hoạt động , hãy cùng khám phá những gì CNCF cung cấp cho hệ sinh thái Serverless. Chúng tôi sẽ so sánh các dự án mã nguồn mở khác nhau và tìm hiểu cách chúng hướng tới để tránh bị khóa vào bất kỳ nhà cung cấp nào."></head><body class=terminal><div class=container><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt"><a href=https://trungtd.me/ class="no-style site-name">TrungTD</a>:~#
<a href=https://trungtd.me/posts>posts</a>/<a href=https://trungtd.me/posts/state-of-serverless>state-of-serverless</a>/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"><li><a href=https://trungtd.me/about/ typeof="ListItem">about/</a></li><li><a href=https://trungtd.me/posts/ typeof="ListItem">posts/</a></li><li><a href=https://trungtd.me/projects/ typeof="ListItem">projects/</a></li></ul></nav></div></div><div class="container animated zoomIn fast"><h1>Hiện trạng của Serverless</h1>Mar. 25, 2022<br><br><p>Bây giờ bạn đã có định nghĩa ban đầu về serverless và hai quan điểm chính về cách nó nên được xây dựng và hoạt động , hãy cùng khám phá những gì CNCF cung cấp cho hệ sinh thái Serverless. Chúng tôi sẽ so sánh các dự án mã nguồn mở khác nhau và tìm hiểu cách chúng hướng tới để tránh bị khóa vào bất kỳ nhà cung cấp nào.</p><p>Đến cuối chương này, bạn nên biết:</p><ul><li>Những sáng kiến ​​nào tồn tại trong CNCF xung quanh Serverless.</li><li>Cách cơ bản Serverless được thực hiện trên Kubernetes.</li><li>Định nghĩa Serverless 2.0.</li><li>Tổng quan cấp cao về các khung mã nguồn mở Serverless 2.0 hàng đầu.</li></ul><h2 id=hiện-trang-của-serverless-trong-kubernetes>Hiện trang của Serverless trong Kubernetes</h2><p>Khi nói về Serverless trong phạm vi Kubernetes, bối cảnh CNCF Serverless phân tách chúng thành các dịch vụ có thể được “cài đặt” và vận hành trên một cụm và các dịch vụ được lưu trữ dưới dạng sản phẩm SaaS.</p><p>Phần khởi đầu nhỏ nhất cho workload trong Kubernetes là Pod, có thể được tạo thành từ một hoặc nhiều containers - chẳng hạn như workload chính và sau đó là một trình trợ giúp như proxy hoặc trình thu thập log. Pod tải mã và user-space từ container image được lưu trữ trong container registry.</p><p>Để truy cập các Pod trong một cụm, các nguyên tắc mạng Kubernetes khác nhau sẽ hoạt động, chẳng hạn như Service, LoadBalancer và Ingress. Mỗi cách này cung cấp một số cách hơi khác nhau để gửi lưu lượng đến workload đang chạy.</p><p>Các yếu tố cơ bản của ta đối với Serverless trên Kubernetes là:</p><ul><li>Một container image với mã chức năng hoặc tệp thực thi bên trong.</li><li>Một registry để lưu trữ hình ảnh vùng chứa.</li><li>Một Pod để chạy container image.</li><li>Service truy cập Pod.</li></ul><p>Thông thường, các dự án sẽ thêm nhiều thành phần khác ở trên cùng của stack này, chẳng hạn như giao diện người dùng và cAPI gateway, Ingress automation, auto-scaling, APIs và nhiều thành phần khác.</p><p>Các dự án xây dựng trên các nguyên tắc trên có mức độ tương thích tương đối tốt; ví dụ: workloads được xây dựng cho OpenFaaS và chạy trên Knative và ngược lại.</p><h2 id=serverless-10-và-serverless-20>Serverless 1.0 và Serverless 2.0</h2><p>Trong thế giới Serverless 1.0, các nhà cung cấp đám mây đã tạo ra các sản phẩm độc lập mà không cần quan tâm đến tính di động hoặc di chuyển giữa các sản phẩm. Thông thường, việc chuyển từ AWS Lambda sang Azure Functions sẽ liên quan đến việc làm lại chữ ký, cách tạo tệp zip, cách truy cập các dịch vụ được quản lý và xử lý các vùng khả dụng khác nhau, khu vực và giới hạn cứng như RAM và kích thước function image.</p><p>Đối với một số khách hàng trong doanh nghiệp, việc giới hạn hình ảnh chức năng 256mb, thời lượng cuộc gọi tối đa 5 phút và dung lượng RAM tối đa là 2GB là quá hạn chế so với nhu cầu của họ. Hơn nữa, Serverless 1.0 không cung cấp câu trả lời cho các dịch vụ nhỏ mà nhiều công ty có.</p><p><img src=serverless1.0.png alt=serverless1.0></p><p>Workload của Serverless 2.0 linh hoạt hơn nhiều so với 1.0. Định nghĩa Serverless 2.0 như sau:</p><ul><li>Được lưu trữ trong container image tương thích OCI.</li><li>Hiển thị một máy chủ HTTP trên cổng 8080.</li><li>Có thể được cấu hình với các biến môi trường.</li></ul><p>Định nghĩa tương đối ngắn gọn này là thứ cho phép mã được viết bằng Node.js, Go, Python hoặc bất kỳ tệp nhị phân nào khác được di chuyển giữa các nền tảng FaaS một cách dễ dàng. Serverless 2.0 là thứ làm cho các chức năng của OpenFaaS trở nên linh hoạt. Có thêm lợi ích là có thể chạy các dịch vụ nhỏ - chẳng hạn như Ruby on Rails, Express.js, Vert.x và Micronaut.</p><h2 id=bức-tranh-chung-về-serverless-20>Bức tranh chung về Serverless 2.0</h2><p>Các framework này tuân theo định nghĩa Serverless 2.0 và có sức hút nhất trong phân đoạn Serverless của CNCF Landscape. Một số dự án được tạo ra một cách hữu cơ bởi các nhà phát triển độc lập, trong khi những dự án khác là nỗ lực của các công ty phần mềm thương mại.</p><p><img src=Serverless_2.0_Landscape.png alt=Serverless_2.0_Landscape></p><p>Bức tranh chung này được chia nhỏ hơn nữa thành các khả năng được cung cấp. Vì vậy, chẳng hạn, OpenFaaS và Knative cung cấp chức năng trong hầu hết các hộp, trong khi Buildpacks, CloudEvents và Keda chỉ dành riêng cho một số danh mục nhất định và dựa vào các dự án khác để lấp đầy khoảng trống.</p><h2 id=các-nền-tảng-serverless>Các nền tảng Serverless</h2><h3 id=openfaas>OpenFaaS</h3><p><a href=https://github.com/openfaas/faas>OpenFaaS</a> được tạo ra để các nhà phát triển có thể sử dụng phần cứng của riêng họ để chạy các chức năng bằng các Docker containers. Nó có hơn 22k stars trên GitHub và một cộng đồng lớn gồm các nhà phát triển phần mềm độc lập và người dùng cuối như BT, Citrix, LivePerson và Vision Banco:</p><ul><li><p><strong>Build templates</strong>: OpenFaaS cung cấp bộ mẫu xây dựng riêng có thể được sử dụng để tạo các hàm. Các mẫu cũng có thể được khám phá và chia sẻ trực tuyến thông qua Template Store.</p></li><li><p><strong>Serving runtime</strong>: OpenFaaS là serving runtime trưởng thành nhất và có nhiều sao nhất trên toàn cảnh. Nó hỗ trợ tự động mở rộng quy mô với Prometheus hoặc Kubernetes HPAv2. Nó có thể scale to zero và quay lại một lần nữa để tiết kiệm tài nguyên. Runtime phân phối đi kèm với REST API, CLI và UI. OpenFaaS có hỗ trợ chuyển đổi lưu lượng với Istio hoặc Linkerd2. OpenFaaS tuân theo định nghĩa Serverless 2.0.</p></li><li><p><strong>Events</strong>: OpenFaaS có một số trình kích hoạt sự kiện, bao gồm Apache Kafka, NATS, AWS SQS, Cron, MQTT và các trình kích hoạt khác. Một trình kết nối-sdk được tạo sẵn cho Golang để các trình kết nối mới có thể được viết trong một khoảng thời gian ngắn.</p></li><li><p><strong>Scale from Zero</strong>: Thu phóng đến và từ 0 được hỗ trợ</p></li><li><p><strong>Managed</strong>: OpenFaaS Cloud là một dịch vụ được quản lý được xây dựng trực tiếp trên OpenFaaS, cung cấp hỗ trợ nhiều người dùng, bảng điều khiển, chỉ số phong phú và tích hợp với GitHub / GitLab. OpenFaaS Cloud là mã nguồn mở và có thể được lưu trữ.</p></li></ul><h3 id=knative>Knative</h3><p>Ban đầu được phát triển tại Google, <a href=https://github.com/knative/serving>Knative</a> hiện có các cộng tác viên từ IBM, RedHat và VMware. Phạm vi của Knative khi ra mắt bao gồm: events, build và serving. Kể từ khi ra mắt, dự án build đã không còn được sử dụng và được thay thế bởi dự án Tekton độc lập để tạo các build và CI pipelines:</p><ul><li><p><strong>Build templates</strong>: Knative không có bộ mẫu riêng, nhưng có thể sử dụng OpenFaaS hoặc Buildpacks. Hầu hết người dùng duy trì Dockerfiles và mã boiler-plate của riêng họ. Knative tuân theo định nghĩa Serverless 2.0.</p></li><li><p><strong>Serving runtime</strong>: Thời gian chạy phục vụ của Knative được gọi là “Knative serve” và yêu cầu một cổng API riêng biệt như Ambassador, Istio hoặc Gloo để hoạt động. Knative thường được cài đặt cùng với Istio để cung cấp dịch chuyển lưu lượng truy cập. Mỗi lần triển khai dịch vụ là không thay đổi và nội bộ tạo một bản sửa đổi cho phép người dùng quay lại phiên bản mã trước đó.</p></li><li><p><strong>Events</strong>: Dự án tổ chức sự kiện Knative bao gồm tất cả các tích hợp với các event. Có một tập hợp 4-5 nguyên thủy được yêu cầu để nhận các sự kiện từ một broker. Khi đúng vị trí, các function có thể được kích hoạt từ nhiều nguồn sự kiện khác nhau.</p></li><li><p><strong>Scale from Zero</strong>: Knative có hỗ trợ thu phóng đến và từ 0. Cold-start time là cao đáng kể; tuy nhiên, dự án đang tích cực cố gắng tìm cách giảm độ trễ.</p></li></ul><h3 id=google-cloud-run>Google Cloud Run</h3><p><a href=https://cloud.google.com/run>Google Cloud Run</a> thực sự không phải là một nền tảng có thể cài đặt và, không giống như các nền tảng khác được liệt kê, nó không phải là mã nguồn mở, nhưng nó tuân theo định nghĩa Serverless 2.0. Điều này cung cấp sự cân bằng giữa. Bạn có thể xây dựng vùng chứa cho OpenFaaS hoặc Knative và sau đó triển khai nó lên Cloud Run. Nền tảng này được lập hóa đơn như một SaaS và có một số giới hạn nhất định (kể từ tháng 6 năm 2020, không thể sử dụng quá 2GB RAM và thời gian thực thi được giới hạn trong 15 phút).</p><h3 id=keda>KEDA</h3><p><a href=https://github.com/kedacore/keda>KEDA</a> chủ yếu quan tâm đến các hàm gọi từ các event và sử dụng các mẫu xây dựng Hàm Azure để xác định các hàm. Vào ngày 31 tháng 3 năm 2020, KEDA đã được tài trợ cho CNCF như một dự án Sandbox. Bạn có thể đọc thêm về nó trong một số bài viết blog.</p><p>Liên quan mật thiết đến KEDA là Azure Functions, cung cấp nền tảng triển khai kiểu serverless 1.0 được lưu trữ trên đám mây.</p><h3 id=rio>Rio</h3><p><a href=https://github.com/rancher/rio>Rio</a> nhằm mục đích cung cấp PaaS trọng lượng nhẹ, theo kiểu serverless. Ban đầu được xây dựng bởi Rancher như một nhánh của Knative, dự án đã phát triển để xây dựng lại một số khái niệm Knative theo cách riêng của nó, chẳng hạn như các bản sửa đổi và dịch vụ mà không phụ thuộc nhiều vào dự án thượng nguồn.</p><p>Rio là dự án duy nhất khác trong bối cảnh Serverless 2.0 có giao diện người dùng chính thức của riêng nó. Rio hiện đang trong giai đoạn thử nghiệm.</p><h3 id=cloudevents>CloudEvents</h3><p>là đặc tả kỹ thuật được viết bởi một số người tham gia trong CNCF’s Serverless Working Group. Trong khi định nghĩa Serverless 2.0 cho phép các chức năng di động giữa các đám mây, dữ liệu vẫn khó trích xuất. Dự án CloudEvents có các đại diện từ AWS, Oracle, Azure và Google và nhằm mục đích làm cho dữ liệu từ các dự án SaaS như cơ sở dữ liệu và kho lưu trữ đối tượng dễ sử dụng hơn trên bất kỳ đám mây nào khác. Phần mềm bao gồm: một SDK có thể được sử dụng trong một số ngôn ngữ lập trình khác nhau cùng với đặc điểm kỹ thuật cho định dạng sự kiện hiện đang ở v1.0. CloudEvents cũng là một dự án sandbox của CNCF.</p><h2 id=cncf-serverless-working-group>CNCF Serverless Working Group</h2><p>The <a href=https://github.com/cncf/wg-serverless>Serverless Working Group</a> đã được CNCF thành lập vào năm 2017 dành cho những người quan tâm đặc biệt đến Serverless và FaaS. Kết quả thu được đầu tiên của nó là một phần lớn phân tích nhằm xác định các thuật ngữ Serverless và FaaS, và một bản thảo đặc tả đã được xuất bản. Ngay sau đó, CloudEvents đã được khởi động và nhanh chóng đạt được phiên bản 1.0 ổn định cùng với việc được tặng cho CNCF như một dự án sandbox. Nhóm làm việc cũng đang khám phá các chủ đề liên quan khác, chẳng hạn như chuỗi chức năng và quy trình làm việc.</p><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap" rel=stylesheet><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script><style>html{text-align:justify;text-justify:inter-word}.post-content img{border-radius:4px;margin:auto}.katex-display{overflow-x:scroll;min-height:4.5rem}</style><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})})</script></div></body></html>